# coding: utf-8

import os
import sys
import time
from datetime import datetime
from typing import Any
import requests
import json
import requests
import stix2
import yaml
from pydantic import ValidationError
from pycti import (
    AttackPattern,
    OpenCTIConnectorHelper,
    StixCoreRelationship,
    get_config_variable,
    Note,
    Malware
    
)
from models import VendorIntelModel
from threading import Lock
from vendorintel import VendorIntel

class Bazar:

    def __init__(self) -> None:
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )
        
        self.helper = OpenCTIConnectorHelper(config)
        self.api_url = get_config_variable(
            "BAZAR_API_URL", ["bazar", "api_url"], config, False, "https://mb-api.abuse.ch/api/v1/"
        )
        #TODO
        #get current epoch time
        self.latest_request_timestamp = datetime.now()
        
        self.vendor_list=["Triage","CAPE","UnpacMe","VMRay","Intezer","vxCube","ANY.RUN","FileScan-IO"] #TODO: make this an environment variable
        self.vendor_intel=VendorIntel(config)
        self.connector_dockerized=get_config_variable(
            "CONNECTOR_DOCKERIZED", ["connector", "dockerized"], config, False, False
        )
        
        if not self.connector_dockerized:
            self.helper.connector_config['connection']['host']='localhost'
        
        self.helper.log_info("Bazar connector started")
        
        self.labels_color = get_config_variable("BAZAR_LABELS_COLOR",["bazar","labels_color"],config,False,"#ff9900")
        
        self.failure_tag_name="bazar_enrich_failure" #TODO: make this an environment variable
        
        self.query_status_notes={
            "hash_not_found": "The hash queried was unknown to MalwareBazar at time {}.",
            "illegal_hash":"The hash queried was not a valid MD5, SHA1 or SHA256 hash",
            "no_hash_provided":"No hash was provided",
            
        }
        blacklist=get_config_variable("BAZAR_BLACKLIST",["bazar","blacklist"],config,False,[])
        with open(blacklist) as f:
            self.blacklist=[line.strip() for line in f.read().splitlines()]
            
    def __build_malware_from_signature(self,signature,indicator_id):
        malware=stix2.Malware(
            id=Malware.generate_id(signature),
            name=signature,
            is_family=False,
        )
        return malware
        
    def __remove_failure_tag(self,observable_id):
        self.helper.api.stix_cyber_observable.remove_label(
            id=observable_id, label_name=self.failure_tag_name
        )
    
    def __filter_attack_patterns_with_blacklist(self,attack_patterns):
        return [attack_pattern for attack_pattern in attack_patterns if not attack_pattern["name"] in self.blacklist]

    def mark_as_enriched(self,observable,tag='SUCCESS'):
        self.helper.log_info("Marking observable as enriched...")
        tag_ha = self.helper.api.label.create(value="BAZAR_ENRICH_{}".format(tag), color="#0059f7")
        self.helper.api.stix_cyber_observable.add_label(id=observable["id"], label_id=tag_ha["id"])
        if tag == 'SUCCESS':
            self.__remove_failure_tag(observable["id"])
        #add the enrichment tag
        
    def __add_objects_to_indicator(self,indicator_id,objects):
        relationships=[]
        print("Indicator ID: {}".format(indicator_id))
        for object in objects:
            relationship=stix2.Relationship(
                source_ref=indicator_id,
                relationship_type="indicates",
                target_ref=object["id"]
            )
            relationships.append(relationship)
        
        all_objects=objects+relationships
        bundle=stix2.Bundle(objects=all_objects)
        bundle=bundle.serialize()
        self.helper.send_stix2_bundle(bundle)
             

    def add_vendor_intel(self,observable,data):
        vendor_intel_objects=[]
        try:
            vendor_intel=VendorIntelModel(**data)
        except ValidationError as e:
            self.helper.log_error("Failed to parse vendor intel data: {}".format(e))
            raise e

        for vendor in self.vendor_intel.vendor_function_map.keys():
            self.helper.log_info("Extracting {} intel...".format(vendor))
            if not vendor in data:
                continue
            self.helper.log_info("Found {} intel...".format(vendor))
            vendor_data = data[vendor]
            if vendor_data:
                vendor_intel_objects.extend(self.vendor_intel.extract_vendor_intel(observable["id"],data,vendor))
            
        vendor_intel_objects=self.__filter_attack_patterns_with_blacklist(vendor_intel_objects)
        return vendor_intel_objects

    
    def _send_knowledge(self,observable,data):
        
        final_observable=observable
        final_observable = self.helper.api.stix_cyber_observable.update_field(
                id=final_observable["id"],
                input={"key": "hashes.MD5", "value": data["md5_hash"]},
            )
        
        final_observable = self.helper.api.stix_cyber_observable.update_field(
            id=final_observable["id"],
            input={"key": "hashes.SHA-1", "value": data["sha1_hash"]},
            )
        final_observable = self.helper.api.stix_cyber_observable.update_field(
            id=final_observable["id"],
            input={"key": "hashes.SHA-256","value": data["sha256_hash"],},
            )
        #create external reference
        external_reference = self.helper.api.external_reference.create(
            source_name="MalwareBazar",
            url="https://bazaar.abuse.ch/sample/" + data["sha256_hash"],
            external_id=data["sha256_hash"],
            description="MalwareBazar Enrichment",
            )
        
        self.helper.api.stix_cyber_observable.add_external_reference(
            id=final_observable["id"], external_reference_id=external_reference["id"]
        )

        #add labels
        for label in data["tags"]:
            label = self.helper.api.label.create(
                value=label,
                color=self.labels_color,
                description="MalwareBazar Enrichment",
            )
            self.helper.api.stix_cyber_observable.add_label(
                id=final_observable["id"], label_id=label["id"]
            )
        
       #update size of file
        final_observable = self.helper.api.stix_cyber_observable.update_field(
            id=final_observable["id"],
            input={"key": "size", "value": str(data["file_size"])},
        )

        #add vendor intel
        vendor_intel_objects=self.add_vendor_intel(final_observable,data["vendor_intel"])
        
        #promote to indicator
        observable=self.helper.api.stix_cyber_observable.promote_to_indicator(id=final_observable["id"])

        indicator=self.helper.api.indicator.read(id=observable['indicatorsIds'][-1])
        #NOTE: promote_to_indicator returns the observable, not the indicator
        #I am assuming that most recently created indicator gets appended at the end of the list ['indicatorIds']
    

        
        #add malware object
        if not data["signature"]=="" and not data["signature"] == None:
            malware=self.__build_malware_from_signature(data["signature"],indicator["standard_id"])
            vendor_intel_objects.append(malware)
        
        self.__add_objects_to_indicator(indicator["standard_id"],vendor_intel_objects)
        

        return "Enriched observable at time " + str(datetime.now()) + " with data from MalwareBazar"

    
    def _process_observable(self,observable):
        self.helper.log_info(
            "Processing the observable " + observable["observable_value"]
        )
        #TODO
        result=[]
        if not observable['entity_type'] in ["StixFile","Artifact"]:
            self.helper.log_error("Unsupported observable type: {}".format(observable['entity_type']))
            return "Unsupported observable type: {}".format(observable['entity_type'])
        

        response=requests.post(
            self.api_url,
            data={"query":"get_info","hash":observable['observable_value']},
        )
        if not response.status_code == 200:
            self.mark_as_enriched(observable,tag='FAILURE')
            self.helper.log_error("API returned status code {} with following text:\n{}".format(response.status_code,response.text))
            return "API returned status code {}".format(response.status_code)
            
        response_data=response.json()
        
        if not response_data['query_status'] == "ok":
            for note in self.query_status_notes.keys():
                if note == response_data['query_status']:  
                    now=datetime.now()
                    note_content=self.query_status_notes[note].format(now)
                    self.helper.api.note.create(
                        stix_id=Note.generate_id(now,note_content),
                        content=note_content,
                        objects=[observable['id']]
                    )        
                    self.mark_as_enriched(observable,tag='FAILURE')
                    return "Marked observable as failure at time {}".format(now)
                
        data=response_data['data']
        self.mark_as_enriched(observable,tag='SUCCESS')
        return self._send_knowledge(observable,data[0])


    def _process_message(self,data,type="observable"):
        if type == "observable":
            entity_id = data["entity_id"]
            observable = self.helper.api.stix_cyber_observable.read(id=entity_id)
            if observable is None:
                raise ValueError(
                    "Observable not found "
                    "(may be linked to data seggregation, check your group and permissions)"
                )
            return self._process_observable(observable)
        else:#if type == "indicator":
            pass
        
        #TODO
    
    def start(self):
        self.helper.listen(self._process_message)
    
